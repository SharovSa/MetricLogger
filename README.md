# MetricLogger

### Формулировка задачи:
Необходимо написать библиотеку/набор классов на C++ для сбора и схранения метрик в файл в текстовом виде.

#### Требования
1. Должна быть возможность добавлять новые типы метрик без переписывания реализации.
2. Запись метрик не должна блокировать потоки, в которых происходят события.
3. После записи метрики накопленные значения обнуляются.


## Описание решения

MetricLogger может логгировать выбранные пользователем метрики c заданным временным интервалом. Интервал логгирования и сами метрики можно менять в процессе работы. Он обрабатывает ошибки ввода-вывода и обеспечивает потокобезопасную работу приложения.

### Архитектура и многопоточность:
1. Для обеспечения расширяемости реализован интерфейс [IMetric](src/imetric.h). Любая новая метрика должна наследоваться от него.
2. Использован паттерн Singleton для реализации [менеджера метрик](src/metric_manager.h), который инициализирует заданные пользователем метрики, управляет их жизненным циклом и логирует их в файл с заданным интервалом. Использование этого паттерна гарантирует централизованный сбор метрик.
3. Для выполнения требования о неблокирующей записи используется паттерн Producer-Consumer:
    - Производитель - это основной поток, который выдает данные для метрик. Он вызывает быстрый метод `add()`, который выполняет атомарные операции или блокирует мьютекс. Это гарантирует быстрый сбор метрик.
    -  Потребитель - это фоновый поток `write_thread_`, которым управляет `MetricManager`. С заданным интервалом он просыпается, чтобы записать все полученные метрики.

    Такое разделение изолирует медленные операции ввода-вывода от потоков приложения.

### Реализованные метрики:
- [CntMetric](src/cnt_metric.h) - потокобезопасный счетчик.
- [AvgMetric](src/avg_metric.h) - потокобезопасный расчет среднего значения.
- [CpuUtilizationMetric](src/cpu_utilization_metric.h) - самостоятельная метрика, которая измеряет среднюю утилизацию CPU.

    Подразумевается, что базовые типы метрик ([CntMetric](src/cnt_metric.h) и [AvgMetric](src/avg_metric.h)) будут получать оценки откуда-то извне, а сами просто обрабатывают их.

## Запуск тестовых примеров

### Тест 1:
В тестовом примере логгируются: средняя утилизация ЦП (для этого нагружаются N-1 ядро математическими вычислениями), количество HTTP-запросов в интервал времени (количество запросов генерируется случайно) и среднее из случайных чисел за интервал времени. Интервал времени логгирования установлен на 1 секунду.
1. Через g++
    ```bash 
    g++ -std=c++17 -o test1 ./src/test1.cpp ./src/metric_manager.cpp ./src/cnt_metric.cpp ./src/avg_metric.cpp ./src/cpu_utilization_metric.cpp -pthread

    ./test1 (.exe для Windows)
    ```
2. Через cmake
    ```bash
    cmake -S . -B build
    cmake --build build
    ./build/test1 (.exe для Windows)
    ```

### Тест 2:
В тестовом примере сначала логгируется только количество HTTP-запросов с интервалом в 2 секунду на проятежении 5 секунд, а потом устанавливается интервал в 1 секунду и добавляется метрика средней утилизации CPU на 5 секунд.

Способы  запуска:
1. Через g++
    ```bash 
    g++ -std=c++17 -o test2 ./src/test2.cpp ./src/metric_manager.cpp ./src/cnt_metric.cpp ./src/avg_metric.cpp ./src/cpu_utilization_metric.cpp -pthread

    ./test2 (.exe для Windows)
    ```
2. Через cmake
    ```bash
    cmake -S . -B build -DBUILD_TEST_1=OFF -DBUILD_TEST_2=ON
    cmake --build build
    ./build/test2 (.exe для Windows)
    ```

Результат работы будет в файле metric.log

