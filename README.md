# MetricLogger

### Формулировка задачи:
Необходимо написать библиотеку/набор классов на C++ для сбора и схранения метрик в файл в текстовом виде.

#### Требования
1. Должна быть возможность добавлять новые типы метрик без переписывания реализации.
2. Запись метрик не должна блокировать потоки, в которых происходят события.
3. После записи метрики накопленные значения обнуляются.

### Краткое описание решения:
Реализован интерфейс [IMetric](src/imetric.h), который позволяет добавлять новые типы метрик без переписывания библиотеки.
Использован паттерн Singleton для реализации [менеджера метрик](src/metric_manager.h), который инициализирует заданные пользователем метрики и логирует их в файл с заданным интервалом. Использование этого паттерна гарантирует централизованный сбор метрик.

Реализованы базовые типы метрик: [метрика-счетчик](src/cnt_metric.h) и [метрика](src/avg_metric.h), которая считает среднее. Подразумевается, что эти типы будут получать оценки откуда-то извне, а сами просто обрабатывают и логгируют их. Также реализована [метрика](src/cpu_utilization_metric.h) для средней утилизации ЦП, которая сама собирает оценки загрузки ЦП.

### Запуск тестового примера
1. Через g++
    ```bash 
    g++ -std=c++17 -o metrics_app ./src/main.cpp ./src/metric_manager.cpp ./src/cnt_metric.cpp ./src/avg_metric.cpp ./src/cpu_utilization_metric.cpp -pthread

    ./metrics_app (.exe для Windows)
    ```
2. Через cmake
    ```bash
    cmake -S . -B build
    cmake --build build
    ./build/MetricLogger (.exe для Windows)
    ```

Результат работы будет в файле metric.log

В тестовом примере логгируются: средняя утилизация ЦП (для этого нагружаются N-1 ядро математическими вычислениями), количество HTTP-запросов в интервал времени (количество запросов генерируется случайно) и среднее из случайных чисел за интервал времени. Интервал времени логгирования установлен на 1 с.